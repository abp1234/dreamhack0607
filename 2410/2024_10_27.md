

1. **프로그램과 Stored-Program 컴퓨터**: 프로그램은 연산 장치가 수행할 동작을 정의한 문서입니다. 초기에는 프로그램을 전선 연결이나 천공 카드로 입력했지만, Stored-Program 컴퓨터의 등장으로 메모리에 저장해 효율적으로 실행할 수 있게 되었습니다. 프로그램은 이진(Binary) 형태로 저장되며, 소프트웨어 개발자들 사이에서 '바이너리'라고 불리기도 합니다.

2. **컴파일러와 인터프리터**: 프로그래밍 언어는 CPU가 이해할 수 있는 기계어로 번역되며, 이 과정을 컴파일(Compile)이라고 합니다. 컴파일러는 한 번 번역된 결과물을 저장해 반복적으로 실행할 수 있게 합니다. 반면, 인터프리터 언어는 실시간으로 명령을 해석해 수행하며, 즉각적이지만 매번 번역을 거쳐야 합니다.

3. **컴파일 과정**: C언어 소스 코드는 전처리(Preprocess), 컴파일(Compile), 어셈블(Assemble), 링크(Link) 단계를 거칩니다.
   - **전처리**는 주석 제거, 매크로 치환, 파일 병합을 포함하며, 소스 코드를 기계어로 번역하기 전 준비하는 단계입니다.



1. **컴파일**: 컴파일(Compile)은 C로 작성된 소스 코드를 어셈블리어로 번역하는 과정입니다. 이 과정에서 컴파일러는 문법 오류를 검사하며, 오류가 있으면 컴파일을 중단하고 에러 메시지를 출력합니다.

2. **최적화 옵션**: 컴파일 시 `-O`, `-O0`, `-O1`, `-O2`, `-O3`, `-Os`, `-Ofast`, `-Og` 등의 옵션을 사용해 최적화 수준을 조절할 수 있습니다. 최적화 옵션을 적용하면 컴파일러가 반복문과 같은 코드를 최적화하여 더 짧고 빠른 어셈블리 코드를 생성합니다.

   예를 들어, `-O2`로 컴파일하면 반복문 결과를 직접 계산해 `x`에 대입하는 코드가 생성됩니다.

3. **어셈블리 코드 생성**: `-S` 옵션을 사용하여 소스 코드를 어셈블리 코드로 컴파일할 수 있습니다. `add.i` 파일을 어셈블리 코드로 변환하면, 메모리 주소와 레지스터를 사용해 연산을 수행하는 어셈블리 코드가 생성됩니다.



1. **어셈블(Assemble)**: 어셈블 단계에서는 컴파일된 어셈블리어 코드가 리눅스에서 ELF 형식의 목적 파일(Object file)로 변환됩니다. 이 과정에서 코드가 기계어로 번역되어 사람이 읽기 어려워집니다. `gcc -c` 명령어로 어셈블이 가능하며, `hexdump`를 통해 목적 파일의 16진수 출력을 확인할 수 있습니다.

2. **링크(Link)**: 링크는 여러 목적 파일을 결합하여 실행 가능한 바이너리를 만드는 과정입니다. 코드에서 호출하는 함수(`printf` 등)가 다른 라이브러리에 있는 경우 링커가 이를 연결해주며, `libc`와 같은 공유 라이브러리도 이 과정에서 참조됩니다. `gcc -Xlinker` 명령어로 링크 에러를 방지하면서 바이너리 파일을 생성할 수 있습니다.


**디스어셈블**은 기계어로 작성된 바이너리 코드를 사람이 읽을 수 있도록 어셈블리어로 변환하는 과정입니다. 이는 어셈블의 반대 과정으로, 바이너리 분석을 위해 사용됩니다. `objdump -d -M intel` 명령어를 통해 디스어셈블된 어셈블리 코드를 확인할 수 있습니다. 디스어셈블 결과는 각 기계어 명령어를 대응하는 어셈블리어 명령어로 번역하여 분석가가 프로그램의 동작을 이해할 수 있도록 도와줍니다.




1. **프로그램**: 컴퓨터가 실행해야 할 명령어의 집합, '바이너리'로 불리기도 함
2. **전처리**: 컴파일을 위해 소스 코드를 가공하는 과정
3. **컴파일**: 소스 코드를 어셈블리어로 번역하는 과정
4. **어셈블**: 어셈블리 코드를 기계어로 번역하여 목적 파일로 변환하는 과정
5. **링크**: 여러 목적 파일과 라이브러리를 연결하여 실행 파일을 만드는 과정
6. **디스어셈블**: 바이너리를 어셈블리어로 번역하는 과정
7. **디컴파일**: 바이너리를 고급 언어로 번역하는 과정


**정적 분석(Static Analysis)**은 프로그램을 실행하지 않고 분석하는 방법으로, 다음과 같은 장단점이 있습니다.

- **장점**:
  - 프로그램의 구조와 함수 간 호출 관계, API 사용 여부, 포함된 문자열 등을 쉽게 파악할 수 있어 큰 관점에서 이해가 용이합니다.
  - 실행 환경의 제약 없이 다양한 시스템에서 분석 가능하므로, 실행이 어려운 파일도 분석할 수 있습니다.
  - 악성 프로그램 실행 없이 안전하게 분석할 수 있어 바이러스 감염 우려가 없습니다.

- **단점**:
  - 코드가 난독화되면 해석이 어려워집니다. 난독화를 해제하기 위한 연구가 있지만, 효과적인 해결책은 제한적입니다.
  - 동적 요소를 다루기 어려워 실행 중 변수나 인자의 정확한 상태를 알기 어렵습니다. 프로그램 흐름이 복잡할수록 이 문제가 커집니다.


  **정적 분석 도구의 예: IDA**

IDA로 `HelloWorld.exe`를 열면 다음과 같은 기능을 통해 프로그램을 분석할 수 있습니다.

- **중앙 화면**: 프로그램의 어셈블리 코드가 표시되어, 코드 흐름을 분석할 수 있습니다.
- **우측 화면**: 디컴파일된 코드가 표시되어, 기계어를 사람이 이해하기 쉬운 고급 언어로 변환하여 분석을 도와줍니다.
- **좌측 화면**: 프로그램의 함수 및 각종 정보를 나열하여 구조를 파악할 수 있습니다.
- **기타 기능**:
  - **상호 참조(Cross Reference)**: 특정 문자열이나 함수가 어디에서 사용되는지 확인 가능
  - **제어 흐름 그래프(Control Flow Graph)**: 함수의 실행 흐름을 시각화하여 쉽게 파악할 수 있도록 지원


**동적 분석(Dynamic Analysis)**은 프로그램을 실행하면서 그 동작을 관찰하는 방법으로, 다음과 같은 장단점이 있습니다.

- **장점**:
  - 프로그램을 실행해 개별 함수나 프로그램의 출력을 직접 확인할 수 있어 복잡한 함수의 동작을 쉽게 추론할 수 있습니다. 예를 들어, MD5와 같은 알고리즘을 실행 결과를 통해 간단히 확인할 수 있습니다.
  
- **단점**:
  - 실행 환경을 구축하기 어려울 수 있으며, 프로그램이 다른 환경에서 실행되지 않으면 가상 머신이나 장치가 필요해 복잡해질 수 있습니다.
  - **안티 디버깅(Anti Debugging)**과 같은 방해 기법이 있어, 디버깅 중임을 감지하고 프로그램을 종료시키는 방식으로 동적 분석을 어렵게 할 수 있습니다.


  **동적 분석 예: x64dbg**

Windows에서 사용되는 동적 분석 도구 **x64dbg**를 통해 `HelloWorld.exe` 프로그램을 실행하며 분석할 수 있습니다.

- **HelloWorld.exe 소스 코드**는 `int n = 0x31337`를 설정하고 이를 출력하는 `printf` 함수를 호출합니다.
- **x64dbg 패널 설명**:
  - **왼쪽 위**: 어셈블리 코드
  - **왼쪽 아래**: 메모리 상태
  - **오른쪽 위**: CPU 레지스터
  - **오른쪽 아래**: 스택 상태

### 단계별 분석 과정
1. `int n = 0x31337` 실행 시, 스택에 값 `0x31337`이 저장됩니다.
2. **스택** 확인: 코드 실행 후 스택에 `0x31337` 저장이 확인됩니다.
3. **printf 호출 전**: 레지스터에서 `rcx`에 문자열, `rdx`에 `0x31337`이 저장된 상태를 확인할 수 있습니다.
4. **printf 호출 결과**: 프로그램이 `Hello World 0x31337`를 출력합니다.

동적 분석을 통해 프로그램 실행 시 **메모리와 레지스터 상태의 변화를 관찰**하며, 함수의 입력값과 실행 흐름을 쉽게 확인할 수 있습니다.

# 컴퓨터 구조와 명령어 집합 구조

컴퓨터 구조(Computer Architecture): CPU, 저장장치, GPU 등 다양한 부품의 조합으로 구성되며, 컴퓨터의 기본 설계입니다.
명령어 집합 구조(ISA): CPU가 사용하는 명령어와 관련된 설계로, x86-64는 가장 널리 쓰이는 ISA 중 하나입니다.
핵심 개념:

범용 레지스터: 여러 연산에 사용되는 레지스터.
세그먼트 레지스터: 메모리 세그먼트를 관리.
플래그 레지스터: CPU 상태 표시.
명령어 포인터 레지스터(IP): 다음 실행 명령어 위치를 저장.


**폰 노이만 구조**는 컴퓨터의 연산, 제어, 저장의 세 가지 핵심 기능을 중심으로 구성됩니다.

1. **중앙처리장치(CPU)**: 컴퓨터의 두뇌 역할로, 산술논리장치(ALU), 제어장치, 레지스터로 구성되어 프로그램의 연산과 제어를 담당합니다.
   
2. **기억장치**:
   - **주기억장치**: RAM처럼 프로그램 실행 중 데이터를 임시로 저장합니다.
   - **보조기억장치**: HDD, SSD 등 영구 데이터 저장을 담당합니다.
   
3. **버스**: 데이터 전송 통로로, **데이터 버스**(데이터 이동), **주소 버스**(주소 지정), **제어 버스**(읽기/쓰기 제어)로 구성됩니다.

또한, **레지스터와 캐시**는 CPU 내부에 위치하여 CPU의 연산 속도에 맞춰 빠르게 데이터를 교환함으로써 주기억장치와의 속도 차이에서 발생하는 병목현상을 줄입니다.

**명령어 집합 구조(ISA)**는 CPU가 해석할 수 있는 명령어들의 집합을 의미하며, 프로그램의 기계어 코드를 CPU가 처리하도록 돕습니다. 다양한 ISA가 존재하는 이유는 컴퓨터의 요구 성능과 환경이 각기 다르기 때문입니다.

- **예시**:
  - **x86-64**: 고성능을 목표로 설계되었으며, 높은 전력 소비와 발열로 인해 데스크톱과 랩톱에 적합합니다.
  - **ARM, MIPS, AVR**: 전력 소모와 발열이 적어 드론, 공유기, 스마트폰 등 임베디드 기기에 주로 사용됩니다.

**x86-64 아키텍처**는 AMD가 인텔의 32비트 아키텍처 IA-32를 64비트로 확장해 개발한 아키텍처로, 현재 대부분의 개인용 컴퓨터에서 사용됩니다.

- **비트 수와 WORD 크기**: `32비트` 아키텍처는 최대 4GB의 가상 메모리를 제공하는 반면, `64비트` 아키텍처는 이론상 16엑사바이트(16EB)의 가상 메모리를 제공하여 대규모 메모리 요구를 충족합니다.

- **다양한 명칭**: x86-64는 AMD와 인텔의 기술 협약으로 인해 여러 이름을 가지며, AMD의 "amd64", 인텔의 "Intel64", "IA-32e", "EM64T" 등으로 불립니다.

**개발 역사**: 인텔의 IA-64가 성능과 호환성 문제로 어려움을 겪는 사이, AMD가 기존 x86과 호환되는 64비트 아키텍처(x86-64)를 발표해 성공을 거두었고, 인텔도 이를 차용해 현재의 x86-64 아키텍처가 널리 사용되게 되었습니다.

**x86-64 아키텍처의 레지스터**는 CPU 내부에서 데이터를 저장하고 빠르게 접근하기 위한 장치로, 주요 레지스터 종류는 다음과 같습니다.

1. **범용 레지스터**:
   - **용도**: 주로 연산 및 데이터 저장에 사용되며 필요에 따라 다양한 목적에 활용됩니다.
   - **주요 레지스터**:
     - `rax`: 함수 반환 값 저장
     - `rcx`: 반복문 횟수 등 카운터 역할
     - `rsp`: 현재 스택 위치
     - `rbp`: 스택 바닥 위치 등

2. **세그먼트 레지스터**: `cs`, `ss`, `ds`, `es`, `fs`, `gs`의 6가지로, 주로 메모리 영역을 구분하며 x64에서 사용 빈도는 낮음.

3. **명령어 포인터 레지스터 (`rip`)**: 현재 실행 중인 코드 위치를 가리키며, x64에서는 8바이트 크기입니다.


**플래그 레지스터 (RFLAGS)**는 CPU의 상태를 나타내는 64비트 레지스터로, 각 비트는 특정 상태를 나타냅니다.

- **주요 플래그**:
  - **CF (Carry Flag)**: 부호 없는 연산에서 비트 범위를 넘었을 때 설정.
  - **ZF (Zero Flag)**: 연산 결과가 0일 때 설정.
  - **SF (Sign Flag)**: 연산 결과가 음수일 때 설정.
  - **OF (Overflow Flag)**: 부호 있는 연산에서 비트 범위를 넘었을 때 설정.

예를 들어, `a=3`, `b=5`에서 `a-b` 연산 시 결과가 음수이므로 SF가 설정되어 `a`가 `b`보다 작음을 알 수 있습니다. RFLAGS는 최대 64개의 비트를 사용할 수 있으나, 실제로는 약 20개의 비트만 사용됩니다.


**레지스터 호환성**: x86-64 아키텍처는 IA-32의 64비트 확장판으로, 이전 아키텍처의 레지스터와 호환됩니다.

- **32비트 레지스터**: IA-32의 레지스터들(`eax`, `ebx`, `ecx`, `edx`, `esi`, `edi`, `esp`, `ebp`)은 x86-64에서도 사용 가능하며, 이는 각각 64비트 레지스터(`rax`, `rbx`, `rcx`, `rdx`, `rsi`, `rdi`, `rsp`, `rbp`)의 하위 32비트를 가리킵니다.
  
- **16비트 및 8비트 레지스터**: IA-16과의 호환성을 위해 `ax`, `bx`, `cx`, `dx` 등은 32비트 레지스터의 하위 16비트를 의미하며, 상위 및 하위 8비트로도 분할 가능합니다. 

이러한 호환성 덕분에 x86-64 아키텍처는 다양한 프로그램과의 연속적인 호환을 유지합니다.

1. **범용 레지스터 (General Register)**: 다양한 용도로 사용 가능한 레지스터로, x64 아키텍처에서는 `rax`, `rbx`, `rcx`, `rdx`, `rsi`, `rdi`, `rsp`, `rbp`, 그리고 `r8`부터 `r15`까지 포함됩니다.

2. **세그먼트 레지스터 (Segment Register)**: 과거 메모리 확장에 사용되었으나, 현재는 주로 메모리 보호 용도로 사용됩니다. x64 아키텍처에는 `cs`, `ss`, `ds`, `es`, `fs`, `gs`가 있습니다.

3. **플래그 레지스터 (Flag Register)**: CPU의 상태를 저장하며, 연산 결과와 관련된 정보를 제공합니다.

4. **명령어 포인터 레지스터 (Instruction Pointer Register)**: CPU가 실행할 명령어의 위치를 가리키는 레지스터로, x64에서는 `rip`로 표현됩니다.


**메모리 레이아웃 (Memory Layout)**은 프로세스가 사용하는 가상 메모리의 구성을 의미하며, 운영체제가 프로그램 실행 시 프로세스에 할당하는 메모리 공간입니다.

- **프로세스 메모리 구획**: 운영체제는 프로그램의 데이터를 용도별로 구획하여 저장하고, 각 구획에 적절한 권한을 부여합니다. 이를 통해 프로그램 메모리를 더 직관적으로 관리하고 보호할 수 있습니다.
  
- **중요성**: 소프트웨어 리버스 엔지니어링에서는 바이너리 동작을 이해하기 위해 바이너리와 상호작용하는 메모리 구조를 알아야 합니다.

**구획**:
- `.text`: 실행 코드
- `.data`: 초기화된 전역/정적 변수
- `.rdata`: 읽기 전용 데이터
- **스택**: 함수 호출 및 지역 변수 저장
- **힙**: 동적 메모리 할당


**프로세스 메모리 구조: 섹션**

Windows의 PE 파일은 **PE 헤더**와 하나 이상의 **섹션**으로 구성됩니다. 섹션은 유사한 용도의 데이터가 모인 영역으로, PE 헤더에 섹션 정보가 저장됩니다.

- **PE 헤더의 주요 섹션 정보**:
  - 섹션 이름
  - 섹션 크기
  - 섹션 로드 주소 오프셋
  - 섹션 속성과 권한

Windows는 PE 파일 실행 시 이 정보를 기반으로 각 섹션을 가상 메모리의 적절한 위치에 매핑합니다. 필수 섹션은 없지만, 일반적으로 `.text`, `.data`, `.rdata` 섹션이 사용됩니다.


**PE 파일의 주요 섹션**:

1. **.text 섹션**:
   - **용도**: 실행 가능한 기계 코드가 위치하며, 프로그램의 코드가 저장되는 영역입니다.
   - **권한**: 읽기 및 실행 권한이 있으며, 보안상 쓰기 권한은 제거됩니다.

2. **.data 섹션**:
   - **용도**: 컴파일 시 값이 정해진 전역 변수들이 위치하며, 프로그램 실행 중 읽고 쓸 수 있는 데이터가 포함됩니다.
   - **권한**: 읽기 및 쓰기 권한이 부여됩니다.

3. **.rdata 섹션**:
   - **용도**: 컴파일 시 값이 정해진 전역 상수와 참조할 DLL 및 외부 함수 정보를 저장하며, 주로 상수와 읽기 전용 데이터를 포함합니다.
   - **권한**: 읽기 전용으로, 데이터 수정은 불가합니다.
   - **특이 사항**: 문자열 상수와 DLL 정보도 저장되며, 과거의 `.idata` 섹션 데이터가 포함됩니다.


**섹션 외 메모리 공간**:

1. **스택 (Stack)**:
   - 각 쓰레드에 독립적으로 할당된 메모리 영역으로, **지역 변수와 함수 리턴 주소** 등을 저장합니다.
   - **권한**: 읽기/쓰기 가능하며, 메모리 주소가 낮은 방향으로 확장되는 특성이 있습니다.

2. **힙 (Heap)**:
   - 프로그램 실행 중 **동적 할당**을 통해 얻는 메모리 공간으로, 스택보다 큰 데이터도 저장 가능합니다.
   - **권한**: 일반적으로 읽기/쓰기 권한을 가지며, 상황에 따라 실행 권한도 가질 수 있습니다.
   - 예시: `malloc()` 함수로 할당한 메모리 영역은 힙에 위치하며, 전역적으로 접근이 가능합니다.




| 섹션      | 역할                                             | 권한         | 사용 예                               |
|-----------|--------------------------------------------------|--------------|---------------------------------------|
| **.text** | 실행 가능한 코드가 저장된 영역                    | 읽기, 실행   | 함수 코드 (e.g., `main()`)            |
| **.data** | 초기화된 전역 변수 저장 영역                     | 읽기, 쓰기   | 초기화된 전역 변수, 전역 상수         |
| **.rdata**| 초기화된 전역 상수와 임포트 데이터 저장 영역     | 읽기 전용    | 전역 상수, 임포트 데이터              |
| **스택**  | 임시 데이터 저장 영역                            | 읽기, 쓰기   | 지역 변수, 함수 인자                  |
| **힙**    | 동적 할당된 메모리 저장 영역                     | 읽기, 쓰기   | `malloc()`, `calloc()` 등 할당 메모리 |



**리버스 엔지니어와 어셈블리 언어**

- **기계어**: 컴퓨터의 언어로 0과 1로 구성되어 있으며, 사람이 이해하기 어려움.
- **어셈블리 언어**: 컴퓨터 과학자 David Wheeler가 개발한 EDSAC에서 시작된 언어로, 기계어를 사람이 더 쉽게 이해하도록 함.
- **어셈블러**: 어셈블리 언어를 기계어로 변환하는 프로그램으로, 개발을 더 쉽게 만들어줌.
- **역어셈블러 (Disassembler)**: 기계어를 어셈블리어로 변환해, 리버스 엔지니어가 소프트웨어를 쉽게 분석하도록 도움.

x86-64 등 주요 아키텍처에 맞는 역어셈블러가 쉽게 구할 수 있어, 어셈블리어만 이해할 수 있다면 소프트웨어 분석이 가능해집니다. 이 커리큘럼에서는 x86-64 어셈블리 언어와 명령어를 소개해 소프트웨어 분석을 위한 기본 언어 지식을 제공합니다.